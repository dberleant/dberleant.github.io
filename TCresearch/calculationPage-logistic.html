<!DOCTYPE html>
<html>
<head>
<title>Curve fitting</title>
</head>
<body>

<h1>Data from TC's "1992 Database - Data Analysis_Dec16.xlsx", 
DB's "yearlyKidneyData-12-17-2023.xlsx", sheet "SummarizedData", cells A1:B21</h1>
<h2>Logistic Model</h2>

<button onclick="document.getElementById('log').innerHTML=''; 
                 searchtMidForMinSSR(steepnessMultiplier);">
	Click to find the logistic curve with the midpoint year and steepness yielding the best fit (lowest SSR)
</button>
<br><br>

<button onclick="document.getElementById('log').innerHTML=''; 
                 searchSteepnessForMinSSR(parseFloat(prompt('Type year of midpoint:'), 10), steepnessMultiplier);">
	Click to find the logistic curve with the best fit steepness for a given midpoint year
</button>
<br><br>

<button onclick="document.getElementById('log').innerHTML=''; 
                 log('SSR = ' + fillInSSR(parseFloat(prompt('Type value for steepness:'), 10),
                                          parseFloat(prompt('Type value for midpoint year:'), 10)
					                     ).SSR
				    );">
	Click to input the steepness and midpoint year, and find the SSR
</button>

<p id="log"></p>


<script>
const supremum = 10; //If the survival period for the data is 10 years, then the maximum average survival time is 10.
const tMidStart = 2000; //year to begin searching upward for midpoint of the logistic curve. Should undercut the midpoint, or it will lead to a non-termination condition.
const minPositiveSteepness = 0.000001; //0.000001 seems smaller than necessary. 0.0001 is probably plenty small.
const steepnessMultiplier=1.1; //1.01 seems awfully small. 2 might be good. But they all seem to work ok.
const minDeltaSSR = 0.00001;

logLifetimeData      = {        name : "LogLifetimeData",
                            populate : // Initialize dataTable's column of lifetime data log values ("LogLifetimeData")
   function(){
      for (dataTableIndex=0; dataTableIndex<dataTable.lifetimeData.length; dataTableIndex++){
         dataTable.logLifetimeData[dataTableIndex]=Math.log2(dataTable.lifetimeData[dataTableIndex]);
      }				 
   }
}    
predictedLifetimes   = {        name : "PredictedLifetimes",
                           steepness : 1,             //initial guess
                                tMid : 2025,          //initial guess
						    populate : // Calculate dataTable's column of lifetime predictions from fail dates (predictedLifetimes)
   function (){
	  if (!isFinite(predictedLifetimes.steepness)||!isFinite(predictedLifetimes.tMid))
	     alert("Error in predictedLifetimes.populate(): non-numeric arg(s)!"); //make sure they are int or float
	  for (dataTableIndex=0; dataTableIndex<dataTable.endYear.length; dataTableIndex++){
         dataTable.predictedLifetimes[dataTableIndex]
            =lifetimeFromFaildate(dataTable.endYear[dataTableIndex],
	                              predictedLifetimes.steepness,
                                  predictedLifetimes.tMid,
								  supremum);
      }
//if (!isFinite(predictedLifetimes.steepness)) alert(dataTable.predictedLifetimes); reports actual numbers. Scary.
   }
}
logPredictedLifetimes= {        name : "LogPredictedLifetime",
                            populate : // Calculate dataTable's column of logs of lifetime predictions ("LogPredictedLifetimes")
   function (){
      for (dataTableIndex=0; dataTableIndex<dataTable.predictedLifetimes.length; dataTableIndex++){
         dataTable.logPredictedLifetimes[dataTableIndex]
            =Math.log2(dataTable.predictedLifetimes[dataTableIndex]);
      }
   }
}
fittingErrors        = {       name : "FittingErrors",
                           populate : // Calculate dataTable's column of fitting errors between lifetime data and lifetime model ("fittingErrors")
   function calcFittingErrors(){
      for (dataTableIndex=0; dataTableIndex<dataTable.logPredictedLifetimes.length; dataTableIndex++){
	     dataTable.fittingErrors[dataTableIndex]  
	        = dataTable.logPredictedLifetimes[dataTableIndex] < dataTable.logLifetimeData[dataTableIndex]
	            ?
	            (dataTable.logLifetimeData[dataTableIndex] - dataTable.logPredictedLifetimes[dataTableIndex]) 
		            / dataTable.logLifetimeData[dataTableIndex]
		        :
		        (dataTable.logPredictedLifetimes[dataTableIndex] - dataTable.logLifetimeData[dataTableIndex]) 
		            / dataTable.logPredictedLifetimes[dataTableIndex];
      }
   }
}
squaredFittingErrors = {        name : "SquaredFittingErrors",
                                 SSR : "uninitialized",
						    populate : // Calculate dataTable's column of squared fitting errors (squaredFittingErrors)
   function (){
      for (dataTableIndex=0; dataTableIndex<dataTable.fittingErrors.length; dataTableIndex++){
         dataTable.squaredFittingErrors[dataTableIndex]
            =dataTable.fittingErrors[dataTableIndex]**2;
      }
   },                        calcSSR : // Calculate SSR
   function (){
      squaredFittingErrors.SSR=0;
      for (dataTableIndex=0; dataTableIndex<dataTable.squaredFittingErrors.length; dataTableIndex++){
		  squaredFittingErrors.SSR += dataTable.squaredFittingErrors[dataTableIndex];
      }
   }
}
predictedStartDates = {         name : "PredictedStartDates",
                            populate : // Calculate dataTable's column of start dates ("predictedStartDates")
   function (){
      for (dataTableIndex=0; dataTableIndex<dataTable.predictedLifetimes.length; dataTableIndex++){
         dataTable.predictedStartDates[dataTableIndex]
            = dataTable.endYear[dataTableIndex] - dataTable.predictedLifetimes[dataTableIndex];
      }
   }
}

let dataTable = {
   key                  : [2002 ,2003 ,2004 ,2005 ,2006 ,2007 ,2008 ,2009 ,2010 ,2011 ,2012 ,2013 ,2014 ,2015 ,2016 ,2017 ,2018 ,2019 ,2020],
   endYear              : [2002 ,2003 ,2004 ,2005 ,2006 ,2007 ,2008 ,2009 ,2010 ,2011 ,2012 ,2013 ,2014 ,2015 ,2016 ,2017 ,2018 ,2019 ,2020],
   lifetimeData         : [2.611,2.576,2.559,2.771,2.655,2.712,2.709,2.882,2.877,2.954,2.973,3.115,3.108,3.192,3.239,3.331,3.273,3.329,3.37],
   logLifetimeData      : [], //to be initialized once
   predictedLifetimes   : [], //to be calculated by the regression process
   logPredictedLifetimes: [], //to be calculated by the regression process
   fittingErrors        : [], //to be calculated by the regression process
   squaredFittingErrors : [], //to be calculated by the regression process
   predictedStartDates  : []  //to be calculated by the regression process
}
logLifetimeData.populate(); //Calculate once as part of initialization.

function updateDataTableFromModelParams(){
   predictedLifetimes   .populate();
   logPredictedLifetimes.populate();
   fittingErrors        .populate();
   squaredFittingErrors .populate(); squaredFittingErrors.calcSSR();
   predictedStartDates  .populate();
}
updateDataTableFromModelParams();

function fillInSSR(steepness, tMid){
   if (!isFinite(tMid)||!isFinite(steepness)) alert("Error in fillInSSR: non-numeric arg(s)");
   predictedLifetimes.steepness = steepness;
   predictedLifetimes.tMid = tMid;
   updateDataTableFromModelParams();
   return({steepness : steepness, tMid : tMid, SSR : squaredFittingErrors.SSR});
}

//returns a string: "positive",           "negative",             "zero or near zero",
//                  "positive edge case", "negative edge case" or "anomaly".
function getSteepnessSign(tMid){
   let SSR0              =fillInSSR(0                    , tMid).SSR; //SSR for          steepness=0
   let SSRminPosSteepness=fillInSSR( minPositiveSteepness, tMid).SSR; //SSR for positive steepness nearest 0
   let SSRmaxNegSteepness=fillInSSR(-minPositiveSteepness, tMid).SSR; //SSR for negative steepness nearest 0
//alert("in getSteepnessSign, SSRs: 0="+SSR0+" SSRminPosSteepness="+
//      SSRminPosSteepness+" SSRmaxNegSteepness="+SSRmaxNegSteepness);
   if      (SSRminPosSteepness< SSR0) return "positive";
   else if (SSRmaxNegSteepness< SSR0) return "negative";
   else if (SSRminPosSteepness> SSR0 && SSRmaxNegSteepness> SSR0)
        return "zero or near zero";
   else if (SSRminPosSteepness> SSR0 && SSRmaxNegSteepness==SSR0)
        return "negative edge case";
   else if (SSRminPosSteepness==SSR0 && SSRmaxNegSteepness> SSR0)
        return "positive edge case";
   else return "anomaly";
}
//alert("getSteepnessSign(2001)="+getSteepnessSign(2001));

function searchSteepnessForMinSSR(tMid, steepnessMultiplier){
 if (!isFinite(tMid)||!isFinite(steepnessMultiplier)) alert("Error in searchSteepnessForMinSSR: non-numeric arg(s)");
   let dataPointLsteepness, dataPointMsteepness, dataPointHsteepness; //L,M,H for low, middle, high absolute value.
   let dataPointTemp; 
   let dataPointLMsteepness, dataPointMHsteepness; //Midway between L&M, M&H, used to focus in on the min.
   let steepness=getSteepnessSign(tMid); //Make it more precise later.
   if      (steepness=="positive") dataPointMsteepness = fillInSSR(steepness= minPositiveSteepness, tMid);
   else if (steepness=="negative") dataPointMsteepness = fillInSSR(steepness=-minPositiveSteepness, tMid);
   else alert("Unhandled return value from getSteepnessSign: "+steepness);
   dataPointLsteepness = fillInSSR(0, tMid);
 if (dataPointLsteepness.SSR < dataPointMsteepness.SSR) {alert("Error #3"); return "Error #3";}
 dataPointHsteepness = fillInSSR(steepness*=steepnessMultiplier, tMid);
   while(!(dataPointMsteepness.SSR <= dataPointHsteepness.SSR)){ //exit when min SSR occurs between steepnesses L and H
//alert("starting while");
	  dataPointLsteepness = dataPointMsteepness;
	  dataPointMsteepness = dataPointHsteepness;
//alert("about to call fillInSSR ");
      dataPointHsteepness = fillInSSR(steepness*=steepnessMultiplier, tMid);
//alert("finished call to fillInSSR");
   }
/*
alert( dataPointLsteepness.steepness
	  +","
	  +dataPointMsteepness.steepness
	  +","
	  +dataPointHsteepness.steepness);
alert( dataPointLsteepness.SSR
	  +","
	  +dataPointMsteepness.SSR
	  +","
	  +dataPointHsteepness.SSR);
*/
//alert("before for");

   for (var deltaSSR=dataPointLsteepness.SSR-dataPointMsteepness.SSR ; 
        !(deltaSSR<minDeltaSSR)                                      ; 
		deltaSSR    =dataPointLsteepness.SSR-dataPointMsteepness.SSR ){
//alert("deltaSSR is "+deltaSSR+", !(deltaSSR<minDeltaSSR) is "+!(deltaSSR<minDeltaSSR));
      dataPointLMsteepness = fillInSSR((dataPointLsteepness.steepness+dataPointMsteepness.steepness)/2, tMid);
      dataPointMHsteepness = fillInSSR((dataPointMsteepness.steepness+dataPointHsteepness.steepness)/2, tMid);
//alert(dataPointLsteepness.SSR+","+dataPointLMsteepness.SSR+","+dataPointMsteepness.SSR+","
//      +dataPointMHsteepness.SSR+","+dataPointHsteepness.SSR);
      if (  dataPointLsteepness.SSR>dataPointLMsteepness.SSR && dataPointLMsteepness.SSR>dataPointMsteepness.SSR
		 && dataPointMsteepness.SSR<dataPointMHsteepness.SSR && dataPointMHsteepness.SSR<dataPointHsteepness.SSR)
	     {dataPointLsteepness=dataPointLMsteepness;    //M  is lowest, so trim L and H
		  dataPointHsteepness=dataPointMHsteepness;}
      else if 
	     (  dataPointLsteepness.SSR>dataPointLMsteepness.SSR && dataPointLMsteepness.SSR>dataPointMsteepness.SSR
		 && dataPointMsteepness.SSR>dataPointMHsteepness.SSR && dataPointMHsteepness.SSR<dataPointHsteepness.SSR)
	     {dataPointLsteepness=dataPointMsteepness ;    //MH is lowest, so trim L and LM
		  dataPointMsteepness=dataPointMHsteepness;}
      else if 
	     (  dataPointLsteepness.SSR>dataPointLMsteepness.SSR && dataPointLMsteepness.SSR<dataPointMsteepness.SSR
		 && dataPointMsteepness.SSR<dataPointMHsteepness.SSR && dataPointMHsteepness.SSR<dataPointHsteepness.SSR)
	     {dataPointHsteepness=dataPointMsteepness ;    //LM is lowest, so trim H and MH
		  dataPointMsteepness=dataPointLMsteepness;}
	  else{alert("Error in searchSteepnessForMinSSR; anomalous SSR pattern");
           alert(dataPointLsteepness.SSR+","+dataPointLMsteepness.SSR+","+dataPointMsteepness.SSR+","
                 +dataPointMHsteepness.SSR+","+dataPointHsteepness.SSR);
           alert(dataPointLsteepness.steepness+","+dataPointLMsteepness.steepness+","+dataPointMsteepness.steepness+","
                 +dataPointMHsteepness.steepness+","+dataPointHsteepness.steepness);
          }
   }
//alert("after for");
   log("For midpoint year " + tMid + ":<br>" 
       + "steepness " + dataPointLsteepness.steepness + " has SSR " + dataPointLsteepness.SSR + "<br>"
	   + "steepness " + dataPointMsteepness.steepness + " has SSR " + dataPointMsteepness.SSR + "<br>"
	   + "steepness " + dataPointHsteepness.steepness + " has SSR " + dataPointHsteepness.SSR + "<br>"
	  );
   return(dataPointMsteepness);
}

function searchtMidForMinSSR(steepnessMultiplier){
   if (!isFinite(steepnessMultiplier)) alert("Error in searchtMidForMinSSR: steepnessMultiplier is non-numeric!");
   let nexttMid = tMidStart;
   let dataPointLtMid = searchSteepnessForMinSSR(nexttMid  , steepnessMultiplier);
   let dataPointMtMid = searchSteepnessForMinSSR(nexttMid+1, steepnessMultiplier); //search one year at a time
   let dataPointHtMid = searchSteepnessForMinSSR(nexttMid+2, steepnessMultiplier);                                                     
   if ((dataPointLtMid.SSR < dataPointMtMid.SSR) && (dataPointLtMid.steepness>0)) {
      log("Warning: no improvement in survival time detected.");
   };
   for (nexttMid=dataPointHtMid.tMid+1 ; 
        (dataPointMtMid.SSR > dataPointHtMid.SSR)||(dataPointMtMid.steepness<0) ; 
		nexttMid++){
//alert(nexttMid);
	  dataPointLtMid = dataPointMtMid;
	  dataPointMtMid = dataPointHtMid;
	  dataPointHtMid = searchSteepnessForMinSSR(nexttMid, steepnessMultiplier); 
      //log("For midpoint year "+dataPointLtMid.tMid+", steepness with lowest SSR is "
	  //    +dataPointLtMid.steepness+" with SSR "+dataPointLtMid.SSR);
   }
   log("<hr><hr><b>Summary: here is the region of best tMid (that is, the midpoint time with lowest SSR):</b>");
   log("For midpoint year "+dataPointLtMid.tMid+", steepness with lowest SSR is "+dataPointLtMid.steepness+" with SSR "+dataPointLtMid.SSR);
   log('<span style="background-color: yellow;"><b>For midpoint time ' 
        + dataPointMtMid.tMid 
		+ ", steepness with lowest SSR is " 
		+ dataPointMtMid.steepness 
		+ " and SSR " 
		+ dataPointMtMid.SSR 
		+ " (best midpoint time and steepness with lowest SSR!)</b></span>"
	  );
   log("For midpoint time "+dataPointHtMid.tMid+", steepness with lowest SSR is "+dataPointHtMid.steepness+" with SSR "+dataPointHtMid.SSR);
}

function log(messageLine){
   document.getElementById("log").innerHTML+=messageLine+"<br>";
}

//alert(Math.sign(-7));

// *** Use bisection method ***
function lifetimeFromFaildate(failDate, steepness, tMid, supremum) { 
  const envelope=0.00001;
  var loBound=0, hiBound=supremum, guessedLife=(hiBound+loBound)/2;
  if (!isFinite(failDate)||!isFinite(steepness)||!isFinite(tMid)) alert("Error in lifetimeFromFaildate, nonnumeric arg(s)");
  if (steepness==0) return(supremum/2); //Special treatment needed since the general formula used in the loop is undefined for steepness 0
  else 
     while ((hiBound-loBound)>envelope){
       ( Math.log(guessedLife)/steepness + guessedLife + tMid - Math.log(supremum - guessedLife)/steepness
	       <
           failDate
		 ==
		 steepness>0
	   )
       ? loBound=guessedLife
       : hiBound=guessedLife;
       guessedLife=(hiBound+loBound)/2;
     }
  return guessedLife; //Has converged on the answer
}
//alert(lifetimeFromFaildate(2036, -.01, 2031,10));

alert("Javascript code loaded");
</script>

</body>
</html>

